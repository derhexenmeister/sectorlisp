file: metacircular/lisp.lisp 

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; We start with some sanity checking of the building blocks from
;; the sectorlisp documentation in lisp.lisp

;; NIL ATOM
;; ABSENCE OF VALUE AND TRUTH
input: NIL
output: NIL

;; CONS CELL
;; BUILDING BLOCK OF DATA STRUCTURES
input: (CONS NIL NIL)
output: (NIL)

input: (CONS (QUOTE X) (QUOTE Y))
output: (X∙Y)

;; REFLECTION
;; EVERYTHING IS AN ATOM OR NOT AN ATOM
input: (ATOM NIL)
output: T

input: (ATOM (CONS NIL NIL))
output: NIL

;; QUOTING
;; CODE IS DATA AND DATA IS CODE
input: (QUOTE (CONS NIL NIL))
output: (CONS NIL NIL)

input: (CONS (QUOTE CONS) (CONS NIL (CONS NIL NIL)))
output: (CONS NIL NIL)

;; LOGIC
;; BY WAY OF STRING INTERNING
input: (EQ (QUOTE A) (QUOTE A))
output: T

input: (EQ (QUOTE T) (QUOTE F))
output: NIL

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Here we test the functions used to build EVAL. The motivation
;; is to understand them via simple standalone examples are explored.

;;;;;
;; ASSOC
;;
;; "The ASSOC function of LISP 1 returned the value associated with a
;;  given key instead of the pair associating the key with the value,
;;  so ASSOC could be used to map atoms directly to their corresponding
;;  values"
;;
;; "The environment is a list of pairs, as described above, suitable
;;  for submitting it to ASSOC. It supplies an initial set of bindings
;;  from atoms (symbols) to values."
;;
;;  Nils Holm "Lisp from Nothing" (http://t3x.org/lfn/)
;;  (these quotes are available in the preview lfn-preview.pdf)
;;
;; "assoc[x; a]
;;  If a is an association list such as the one formed by pairlis in the
;;  above example, then assoc will produce the first pair whose first
;;  term is x. Thus it is a table searching function.
;;
;;  We have:
;;    assoc[x;a] = [equal[caar[a];x] -> car[a];T->assoc[x;cdr[a]]]
;;
;;  An example is:
;;    assoc[B;((A . (M N)), (B . (CAR X)), (C . (QUOTE M)),(C . (CDR X)))] = (B . (CAR X)"
;;
;; LISP 1.5 Programmer's Manual, page 12
;; The Computation Center and Research Laboratory of Electronics
;; Massachusetts Institute of Technology
;;

;; Let's make a simple association list by hand
;;
input: (CONS (CONS (QUOTE A) (QUOTE 1)) (CONS (CONS (QUOTE B) (QUOTE 2)) (CONS (CONS (QUOTE C) (QUOTE 3)) NIL)))
output: ((A∙1) (B∙2) (C∙3))

;; We can lookup values in it
input: (ASSOC (QUOTE A) (CONS (CONS (QUOTE A) (QUOTE 1)) (CONS (CONS (QUOTE B) (QUOTE 2)) (CONS (CONS (QUOTE C) (QUOTE 3)) NIL))))
output: 1
input: (ASSOC (QUOTE B) (CONS (CONS (QUOTE A) (QUOTE 1)) (CONS (CONS (QUOTE B) (QUOTE 2)) (CONS (CONS (QUOTE C) (QUOTE 3)) NIL))))
output: 2
input: (ASSOC (QUOTE C) (CONS (CONS (QUOTE A) (QUOTE 1)) (CONS (CONS (QUOTE B) (QUOTE 2)) (CONS (CONS (QUOTE C) (QUOTE 3)) NIL))))
output: 3

;; We can also use PAIRLIS to create the association list
;;
input: (PAIRLIS (QUOTE (X Y Z)) (QUOTE (24 25 26)) ())
output: ((X∙24) (Y∙25) (Z∙26))

input: (ASSOC (QUOTE X) (PAIRLIS (QUOTE (X Y Z)) (QUOTE (24 25 26)) ()))
output: 24

input: (ASSOC (QUOTE Y) (PAIRLIS (QUOTE (X Y Z)) (QUOTE (24 25 26)) ()))
output: 25

input: (ASSOC (QUOTE Z) (PAIRLIS (QUOTE (X Y Z)) (QUOTE (24 25 26)) ()))
output: 26

;; For anything not in the association list -> NIL
;;
input: (ASSOC (QUOTE OOPS) (PAIRLIS (QUOTE (X Y Z)) (QUOTE (24 25 26)) ()))
output: NIL

;;;;;
;; EVCON
;;
;; "The EVCON and EVLIS functions used by EVAL implemented the evaluation
;;  of the COND special for m and the evaluation of argument lists in
;;  function applications, respectively."
;;
;;  Nils Holm "Lisp from Nothing" (http://t3x.org/lfn/)
;;  (this quote is in the preview lfn-preview.pdf)
;;
;; "evcon[c; a] = [eval[caar[c];a] -> eval[cadar[c];a];
;;                T -> evcon[cdr[c];a]]"
;;
;; LISP 1.5 Programmer's Manual, page 13
;;
;; "If car of the form is COND, then it is a conditional expression,
;; and evcon evaluates the propositional terms in order, and choses
;; the form following the first true predicate."
;;
;; LISP 1.5 Programmer's Manual, page 14
;;
;; "COND, for example, has a very special way of evaluating its arguments
;;  by using evcon"
;;
;; LISP 1.5 Programmer's Manual, page 18-19

;; (EVCON C A)
;;
input: (EVCON (QUOTE (((EQ (QUOTE A) (QUOTE A)) (QUOTE TRUE))) NIL))
output: TRUE

input: (EVCON (QUOTE (((EQ (QUOTE A) (QUOTE B)) (QUOTE TRUE)) ((QUOTE T) (QUOTE FALSE))) NIL))
output: FALSE

;;;;;
;; PAIRLIS
;;
;; "pairlis[x;y;a]
;;  This function gives the list of pairs of corresponding elements of
;;  the lists x and y, and appends this to the list a. The resultant list
;;  of pairs, which is like a table with two columns, is called an
;;  association list.
;;
;;  We have:
;;    pairlis[x;y;a] = [null[x]--a; T-cons[cons[car[x]; car[y]]; pairlis[cdr[x]; cdr[y]; a]]]
;;
;;  An example is:
;;    pairlis[(A B C);(U V W);((D . X) (E . Y))] = ((A . U) (B . V) (C . W)(D . X) (E . Y))"
;;
;; LISP 1.5 Programmer's Manual, pages 11-12
;;
;; If we execute the following program:
;;
;; ((LAMBDA (CONS3 X Y Z) (CONS3 X Y Z))
;;  (QUOTE (LAMBDA (L) (CONS X (CONS Y Z))))
;;  (QUOTE A)
;;  (QUOTE B)
;;  (QUOTE C))
;;
;; The we will see PAIRLIS called with:
;;
;;   Pairlis x> (CONS3 X Y Z)
;;   Pairlis y> ((LAMBDA (L) (CONS X (CONS Y Z))) A B C)
;;   Pairlis a> NIL
;;
;; And then the more obvious looking recursion:
;;   Pairlis x> (X Y Z)
;;   Pairlis y> (A B C)
;;   Pairlis a> NIL
;;
;; This results in:
;;
;;   Pairlis recursion returned si> ((X∙A) (Y∙B) (Z∙C))
;;
;; Where the arguments are paired with their values.
;;
input: (PAIRLIS () () ())
output: NIL

input: (PAIRLIS () () (QUOTE (A B C)))
output: (A B C)

input: (PAIRLIS (QUOTE (A)) (QUOTE (B)) ())
output: ((A∙B))

;; Now a simple example where we want to create some pairs in two
;; steps
;;
;; a b c d e f : Parameters
;; n o p q r s : Values

input: (PAIRLIS (QUOTE (A B C)) (QUOTE (N O P)) ())
output: ((A∙N) (B∙O) (C∙P))

;; TODO: Not sure how to create A in the correct format without
;; a lot of CONSing
;;
input: (CONS (CONS (QUOTE C) (QUOTE P)) NIL)
output: ((C∙P))
input: (CONS (CONS (QUOTE B) (QUOTE O)) (CONS (CONS (QUOTE C) (QUOTE P)) NIL))
output: ((B∙O) (C∙P))
input: (CONS (CONS (QUOTE A) (QUOTE N)) (CONS (CONS (QUOTE B) (QUOTE O)) (CONS (CONS (QUOTE C) (QUOTE P)) NIL)))
output: ((A∙N) (B∙O) (C∙P))

input: (PAIRLIS (QUOTE (D E F)) (QUOTE (Q R S)) (CONS (CONS (QUOTE A) (QUOTE N)) (CONS (CONS (QUOTE B) (QUOTE O)) (CONS (CONS (QUOTE C) (QUOTE P)) NIL))))
output: ((D∙Q) (E∙R) (F∙S) (A∙N) (B∙O) (C∙P))

;; We can also create the above with PAIRLIS
input: (PAIRLIS (QUOTE (D E F)) (QUOTE (Q R S)) (PAIRLIS (QUOTE (A B C)) (QUOTE (N O P)) ()))
output: ((D∙Q) (E∙R) (F∙S) (A∙N) (B∙O) (C∙P))

;;;;;
;; EVLIS
;;
;; "The EVCON and EVLIS functions used by EVAL implemented the evaluation
;;  of the COND special for m and the evaluation of argument lists in
;;  function applications, respectively."
;;
;;  Nils Holm "Lisp from Nothing" (http://t3x.org/lfn/)
;;  (this quote is in the preview lfn-preview.pdf)
;;
;; "evlis[m;a] = [null[m] -> NIL;
;;              T -> cons[eval[car[m];a];evlis[cdr [m];a]]]"
;;
;; LISP 1.5 Programmer's Manual, page 13
;;

;;;;;
;; APPLY
;;
;; "apply handles a function and its arguments, while eval handles forms.
;; Each of these functions also has another argument that is used as an
;; association list for storing the values of bound variables and function
;; names.
;;
;; ...
;;
;;  apply[fn;x;a] = 
;;    [atom[fn] -> [eq[fn;CAR]  -> caar[x];
;;                  eq[fn;CDR]  -> cdar[x];
;;                  eq[fn;CONS] -> cons[car[x]; cadr[x]];
;;                  eq[fn;ATOM] -> atom[car[x]];
;;                  eq[fn;EQ]   -> eq[car[x]; cadr[x]];
;;                  T           -> apply[eval[fn;a];x;a]];
;;     eq[car[fn];LAMBDA] -> eval[caddr [fn];pairlis[cadr[fn];x;a]];
;;     eq[car[fn];LABEL] ->  apply[caddr[fn];x;cons[cons[cadr[fn];
;;                                            caddr[fn]];a]]]"
;; LISP 1.5 Programmer's Manual, page 13
;;
;; "The first argument for apply is a function. If it is an atomic
;;  symbol, then there are two possibilities. One is that it is an
;;  elementary function: car, cdr, cons, eq, or atom. In each case, the
;;  appropriate function is applied to the argument(s). If it is not
;;  one of these, then its meaning has to be looked up in the association
;;  list.
;;
;;  If it begins with LAMBDA, then the arguments are paired with the
;;  bound variables, and the form is given to eval to evaluate.
;;
;;  If it begins with LABEL, then the function name and definition are
;;  added to the association list, and the inside function is evaluated
;;  by apply."
;;
;; LISP 1.5 Programmer's Manual, page 14
;;
;;  Notes:
;;    The comment about LABEL does not apply to this implementation.

;; (APPLY FN X A)
;;
input: (APPLY (QUOTE EQ) (QUOTE (A A)) NIL)
output: T

input: (APPLY (QUOTE EQ) (QUOTE (A B)) NIL)
output: NIL

input: (APPLY (QUOTE (LAMBDA (L) (CONS 'MY L))) (QUOTE ((LITTLE PONY))) NIL)
output: (MY LITTLE PONY)

;;;;;
;; EVAL
;;
;; "apply handles a function and its arguments, while eval handles forms.
;; Each of these functions also has another argument that is used as an
;; association list for storing the values of bound variables and function
;; names.
;;
;; ...
;;
;; eval[e;a] = [atom[e] -> cdr[assoc[e;a]];
;;       atom[car[e]] ->
;;           [eq[car[e];QUOTE] -> cadr[e];
;;            eq[car[e];COND]  -> evcon[cdr[e];a];
;;            T -> apply[car[e];evlis[cdr[e];a];a]];
;;       T -> apply[car[e];evlis[cdr[e];a];a]]
;;
;; LISP 1.5 Programmer's Manual, page 13
;;
;; "The first argument of eval is a form. If it is atomic, then it must be a
;;  variable, and its value is looked up on the association list.
;;
;;  If car of the form is QUOTE, then it is a constant, and the value is
;;  cadr of the form itself.
;;
;;  If car of the form is COND, then it is a conditional expression, and
;;  evcon evaluates the propositional terms in order, and choses the form
;;  following the first true predicate.
;;
;;  In all other cases, the form must be a function followed by its
;;  arguments. The arguments are then evaluated, and the function is
;;  given to apply."
;; LISP 1.5 Programmer's Manual, page 14
;;
;; "Special Forms
;;  Normally, eval evaluates the arguments of a function before applying
;;  the function itself. Thus if =l is given (CONSX Y), it will evaluate
;;  X and Y, and then cons them. But if eval is given (QUOTE X), X should
;;  not be evaluated. QUOTE is a special form that prevents its argument
;;  from being evaluated.
;;
;;  A special form differs from a function in two ways. Its arguments
;;  are not evaluated before the special form sees them. COND, for example,
;;  has a very special way of evaluating its arguments by using evcon.
;;  The second way which special forms differ from functions is that they
;;  may have an indefinite number of arguments."
;;
;; LISP 1.5 Programmer's Manual, page 18

;; (EVAL E A)

;; Simple demonstation of the environment
;;
input: (EVAL (QUOTE A) (PAIRLIS (QUOTE (A B C)) (QUOTE (APPLE BANANA CARROT))))
output: APPLE

input: (EVAL (QUOTE B) (PAIRLIS (QUOTE (A B C)) (QUOTE (APPLE BANANA CARROT))))
output: BANANA

input: (EVAL (QUOTE C) (PAIRLIS (QUOTE (A B C)) (QUOTE (APPLE BANANA CARROT))))
output: CARROT

;; Quotes are simple
;;
input: (EVAL (QUOTE (QUOTE SHAZAM)) ())
output: SHAZAM

input: (EVAL (QUOTE (QUOTE (ALPHA BETA GAMMA))) ())
output: (ALPHA BETA GAMMA)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; This is the minimal program used to test the metacircular
;; evaluator. We run it twice. First in the C-based LISP, and then
;; via the metacirculator evaluator.

;; FIND FIRST ATOM IN TREE
;; CORRECT RESULT OF EXPRESSION IS `A`
;; RECURSIVE CONDITIONAL FUNCTION BINDING
input: ((LAMBDA (FF X) (FF X)) (QUOTE (LAMBDA (X) (COND ((ATOM X) X) ((QUOTE T) (FF (CAR X)))))) (QUOTE ((A) B C)))
output: A

;; RUN FF IN LISP VERSION OF THE METACIRCULAR EVALUATOR
input: (EVAL (QUOTE ((LAMBDA (FF X) (FF X)) (QUOTE (LAMBDA (X) (COND ((ATOM X) X) ((QUOTE T) (FF (CAR X)))))) (QUOTE ((A) B C)))) ())
output: A
