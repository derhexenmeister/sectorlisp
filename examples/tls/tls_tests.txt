;; These are based on programs from:
;;   The Little Schemer
;;   Fourth Edition
;;   Daniel P. Friedman and Matthias Felleisen
;;
file: tls/chapter2/lat?.lisp 
input: (QUOTE (fried rice and singapore noodles))
output: T

input: (QUOTE (fried (rice) and singapore noodles))
output: NIL

input: (QUOTE a)
output: NIL

; () does not contain a list, so it's T
input: (QUOTE ())
output: T

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
file: tls/chapter2/member?.lisp 
input: (QUOTE bread) (QUOTE (two slices of bread and sliced tomato))
output: T

input: (QUOTE two) (QUOTE (two slices of bread and sliced tomato))
output: T

input: (QUOTE tomato) (QUOTE (two slices of bread and sliced tomato))
output: T

input: (QUOTE bacon) (QUOTE (two slices of bread and sliced tomato))
output: NIL

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
file: tls/chapter3/rember.lisp 
input: (QUOTE rice) (QUOTE (white rice and fried rice and brown rice and rice cakes))
output: (white and fried rice and brown rice and rice cakes)

input: (QUOTE white) (QUOTE (white rice and fried rice and brown rice and rice cakes))
output: (rice and fried rice and brown rice and rice cakes)

input: (QUOTE cakes) (QUOTE (white rice and fried rice and brown rice and rice cakes))
output: (white rice and fried rice and brown rice and rice)

input: (QUOTE chocolate) (QUOTE (white rice and fried rice and brown rice and rice cakes))
output: (white rice and fried rice and brown rice and rice cakes)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
file: tls/chapter3/firsts.lisp 
input: (QUOTE ((c a) (a b) (t u)))
output: (c a t)

input: (QUOTE (((c) (a)) ((a) (b)) ((t) (u))))
output: ((c) (a) (t))

input: (QUOTE ((c)))
output: (c)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
file: tls/chapter3/insertR.lisp 
input: (QUOTE sliced) (QUOTE and) (QUOTE (mango pudding and mango))
output: (mango pudding and sliced mango)

input: (QUOTE cream) (QUOTE ice) (QUOTE (mango pudding and vanilla ice))
output: (mango pudding and vanilla ice cream)

input: (QUOTE mango) (QUOTE thai) (QUOTE (thai coconut pudding and thai iced tea))
output: (thai mango coconut pudding and thai iced tea)

input: (QUOTE candy) (QUOTE cola) (QUOTE (tofu is bean curd))
output: (tofu is bean curd)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
file: tls/chapter3/insertL.lisp 
input: (QUOTE thai) (QUOTE mango) (QUOTE (mango pudding and fresh mango))
output: (thai mango pudding and fresh mango)

input: (QUOTE sugar) (QUOTE cookies) (QUOTE (fresh fruit and cookies))
output: (fresh fruit and sugar cookies)

input: (QUOTE breakfast) (QUOTE tea) (QUOTE (tea))
output: (breakfast tea)

input: (QUOTE hot) (QUOTE breakfast) (QUOTE (breakfast tea and iced tea))
output: (hot breakfast tea and iced tea)

input: (QUOTE candy) (QUOTE cola) (QUOTE (tofu is bean curd))
output: (tofu is bean curd)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
file: tls/chapter3/subst.lisp 
input: (QUOTE tea) (QUOTE coffee) (QUOTE (breakfast coffee and iced tea))
output: (breakfast tea and iced tea)

; When new doesn't exist do nothing
input: (QUOTE tea) (QUOTE latte) (QUOTE (breakfast coffee and iced tea))
output: (breakfast coffee and iced tea)

; First item in list
input: (QUOTE afternoon) (QUOTE breakfast) (QUOTE (breakfast coffee and iced tea))
output: (afternoon coffee and iced tea)

; Last item in list
input: (QUOTE coffee) (QUOTE tea) (QUOTE (hot breakfast coffee and iced tea))
output: (hot breakfast coffee and iced coffee)

; Only the first match
input: (QUOTE milk) (QUOTE coffee) (QUOTE (coffee and iced coffee))
output: (milk and iced coffee)

input: (QUOTE candy) (QUOTE cola) (QUOTE (tofu is bean curd))
output: (tofu is bean curd)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
file: tls/chapter3/subst2.lisp 
input: (SUBST2 (QUOTE vanilla) (QUOTE banana) (QUOTE durian) (QUOTE (banana frozen yogurt with popping boba)))
output: (vanilla frozen yogurt with popping boba)

input: (SUBST2 (QUOTE vanilla) (QUOTE banana) (QUOTE durian) (QUOTE (durian frozen yogurt with popping boba)))
output: (vanilla frozen yogurt with popping boba)

input: (SUBST2 (QUOTE candy) (QUOTE cola) (QUOTE water) (QUOTE (tofu is bean curd)))
output: (tofu is bean curd)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
file: tls/chapter3/multirember.lisp 
input: (QUOTE shrimp) (QUOTE (shrimp fried rice and shrimp rice cakes and shrimp satay))
output: (fried rice and rice cakes and satay)

input: (QUOTE water) (QUOTE (hot water and cold water))
output: (hot and cold)

input: (QUOTE etcetera) (QUOTE (etcetera etcetera etcetera))
output: NIL

input: (QUOTE candy) (QUOTE (tofu is bean curd))
output: (tofu is bean curd)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
file: tls/chapter3/multiinsertR.lisp 

input: (QUOTE rice) (QUOTE white) (QUOTE (white in a bowl and white in a roll))
output: (white rice in a bowl and white rice in a roll)

; appended right after start of list, and at the end
input: (QUOTE cats) (QUOTE cute) (QUOTE (cute or white rats and cute))
output: (cute cats or white rats and cute cats)

input: (QUOTE sweet) (QUOTE candy) (QUOTE (tofu is bean curd))
output: (tofu is bean curd)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
file: tls/chapter3/multiinsertL.lisp 

input: (QUOTE green) (QUOTE tea) (QUOTE (tea))
output: (green tea)

input: (QUOTE fried) (QUOTE fish) (QUOTE (fish or fish and chips or salt and pepper fish))
output: (fried fish or fried fish and chips or salt and pepper fried fish)

input: (QUOTE sweet) (QUOTE candy) (QUOTE (tofu is bean curd))
output: (tofu is bean curd)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
file: tls/chapter3/multisubst.lisp 

input: (QUOTE fudge) (QUOTE topping) (QUOTE (topping ice cream with topping for dessert))
output: (fudge ice cream with fudge for dessert)

input: (QUOTE vegetables) (QUOTE candy) (QUOTE (candy candy candy))
output: (vegetables vegetables vegetables)

input: (QUOTE vegetables) (QUOTE candy) (QUOTE (tofurky and brussel sprouts))
output: (tofurky and brussel sprouts)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Logic (mixed in with numbers)
;
file: tls/chapter4/numbers.lisp 
input: (NOT (QUOTE T))
output: NIL

input: (NOT NIL)
output: T

input: (OR NIL NIL)
output: NIL

input: (OR NIL (QUOTE T))
output: T

input: (OR (QUOTE T) NIL)
output: T

input: (OR (QUOTE T) (QUOTE T))
output: T

input: (AND NIL NIL)
output: NIL

input: (AND NIL (QUOTE T))
output: NIL

input: (AND (QUOTE T) NIL)
output: NIL

input: (AND (QUOTE T) (QUOTE T))
output: T

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Represent numbers with lists for simplicity
; bc can be used to check the answers during test development
;
; $ echo "(1+ 1+ 1+ 1+ 1+ 1+ 1+ 1+ 1+ 1+ 1+ 1+ 1+ 1+ 1+ 1+ 1+ 1+ 1+ 1+ 0)" | bc
; 20
;
file: tls/chapter4/numbers.lisp 
; Constants
input: ZERO
output: (0)

input: ONE
output: (1+ 0)

input: TWO
output:  (1+ 1+ 0)

input: THREE
output: (1+ 1+ 1+ 0)

input: FOUR
output: (1+ 1+ 1+ 1+ 0)

input: FIVE
output: (1+ 1+ 1+ 1+ 1+ 0)

; Incrementing by one
input: (ADD1 ZERO)
output: (1+ 0)

; Decrementing by one
input: (SUB1 FIVE)
output: (1+ 1+ 1+ 1+ 0)

; Adding two numbers
input: (+ FOUR FIVE)
output: (1+ 1+ 1+ 1+ 1+ 1+ 1+ 1+ 1+ 0)

; Subtracting two numbers
input: (- FIVE FOUR)
output: (1+ 0)

; Nested addition and subtraction
input: (- FIVE (+ FOUR ONE))
output: (0)

; Nested plus check for zero
input: (ZERO? (- FIVE (+ FOUR ONE)))
output: T

; Multiplying two numbers
input: (* FIVE FOUR)
output: (1+ 1+ 1+ 1+ 1+ 1+ 1+ 1+ 1+ 1+ 1+ 1+ 1+ 1+ 1+ 1+ 1+ 1+ 1+ 1+ 0)

; Sanity check multiplication by zero
input: (* FIVE ZERO)
output: (0)

input: (* ZERO FIVE)
output: (0)

; Integer division
input: (/ FIVE ZERO)
output: *UNDEFINED

input: (/ FIVE ONE)
output: (1+ 1+ 1+ 1+ 1+ 0)

input: (/ FIVE TWO)
output: (1+ 1+ 0)

input: (/ FIVE THREE)
output: (1+ 0)

input: (/ FIVE FOUR)
output: (1+ 0)

input: (/ FIVE FIVE)
output: (1+ 0)

input: (/ FIVE (+ FIVE ONE))
output: (0)

input: (/ (* FOUR FIVE) TWO)
output: (1+ 1+ 1+ 1+ 1+ 1+ 1+ 1+ 1+ 1+ 0)

; Checking for zero

; Empty list is not considered zero here
input: (ZERO? (QUOTE ()))
output: NIL

; Zero must be a list
input: (ZERO? (QUOTE 0))
output: NIL

; Zero must be a in a list of atoms, no sublists
input: (ZERO? (QUOTE ((0))))
output: NIL

input: (ZERO? ZERO)
output: T

input: (ZERO? ONE)
output: NIL

; 0 must be last in the list
input: (ZERO? (QUOTE (0 A)))
output: NIL

; Checking for valid number

; Empty list is not considered to be a number
input: (NUMBER? (QUOTE ()))
output: NIL

; Zero must be a list
input: (NUMBER? (QUOTE 0))
output: NIL

; And zero must be a lat
input: (NUMBER? (QUOTE ((0))))
output: NIL

; One must be a list too
input: (NUMBER? (QUOTE 1+))
output: NIL

; And the one list must be terminated with a 0
input: (NUMBER? (QUOTE (1+)))
output: NIL

; And the one list must not have anything after the terminator
input: (NUMBER? (QUOTE (1+ 0 0)))
output: NIL

input: (NUMBER? ZERO)
output: T

input: (NUMBER? ONE)
output: T

; Remove numbers from lat
input: (NO-NUMS (QUOTE ()))
output: NIL

input: (NO-NUMS (QUOTE (A B C D)))
output: (A B C D)

input: (NO-NUMS (QUOTE ((0) (1+ 0) (1+ 1+ 0) (1+ 1+ 1+ 0))))
output: NIL

input: (NO-NUMS (QUOTE ((0) A (1+ 0) B (1+ 1+ 0) C (1+ 1+ 1+ 0) D)))
output: (A B C D)

input: (NO-NUMS (QUOTE (A (0) B (1+ 0) C (1+ 1+ 0) D (1+ 1+ 1+ 0))))
output: (A B C D)

; malformed #'s won't be filtered, valid #'s will be
input: (NO-NUMS (QUOTE (A (0 X) B (1+ 0 0) C (1+ 1+ 0 1+) D (1+ 1+ 1+ 0))))
input: (A (0 X) B (1+ 0 0) C (1+ 1+ 0 1+) D (1+ 1+ 1+ 0))

; Remove non-numbers from lat
input: (ALL-NUMS (QUOTE ()))
output: NIL

input: (ALL-NUMS (QUOTE (A B C D)))
output: NIL

input: (ALL-NUMS (QUOTE ((0) (1+ 0) (1+ 1+ 0) (1+ 1+ 1+ 0))))
output: ((0) (1+ 0) (1+ 1+ 0) (1+ 1+ 1+ 0))

input: (ALL-NUMS (QUOTE ((0) A (1+ 0) B (1+ 1+ 0) C (1+ 1+ 1+ 0) D)))
output: ((0) (1+ 0) (1+ 1+ 0) (1+ 1+ 1+ 0))

input: (ALL-NUMS (QUOTE (A (0) B (1+ 0) C (1+ 1+ 0) D (1+ 1+ 1+ 0))))
output:  ((0) (1+ 0) (1+ 1+ 0) (1+ 1+ 1+ 0))

; malformed #'s will be filtered, valid #'s won't
input: (ALLO-NUMS (QUOTE (A (0 X) B (1+ 0 0) C (1+ 1+ 0 1+) D (1+ 1+ 1+ 0))))
input: ((1+ 1+ 1+ 0))

; Powers
input: (^ FIVE ZERO)
output: (1+ 0)

input: (^ FIVE ONE)
output: (1+ 1+ 1+ 1+ 1+ 0)

input: (^ FIVE TWO)
output: (1+ 1+ 1+ 1+ 1+ 1+ 1+ 1+ 1+ 1+ 1+ 1+ 1+ 1+ 1+ 1+ 1+ 1+ 1+ 1+ 1+ 1+ 1+ 1+ 1+ 0)

; Summing elements of a tuple of numbers
;
; TODO - can't use symbolic input?
;
input: (ADDTUP (QUOTE ((1+ 0) (1+ 1+ 1+ 0) (1+ 1+ 1+ 1+ 0))))
output: (1+ 1+ 1+ 1+ 1+ 1+ 1+ 1+ 0)

; Only one number in tuple
input: (ADDTUP (QUOTE ((0))))
output: (0)

input: (ADDTUP (QUOTE ((1+ 0))))
output: (1+ 0)

; Adding elements of two tuples
;
input: (TUP+ NIL NIL)
output: NIL

; Unequal lengths with and without using nil
input: (TUP+ NIL (QUOTE ((1+ 1+ 1+ 0) (1+ 1+ 1+ 1+ 0))))
output: ((1+ 1+ 1+ 0) (1+ 1+ 1+ 1+ 0))

input: (TUP+ (QUOTE ((1+ 1+ 1+ 0) (1+ 1+ 1+ 1+ 0))) NIL)
output: ((1+ 1+ 1+ 0) (1+ 1+ 1+ 1+ 0))

input: (TUP+ (QUOTE ((0))) (QUOTE ((1+ 1+ 1+ 0) (1+ 1+ 1+ 1+ 0))))
output: ((1+ 1+ 1+ 0) (1+ 1+ 1+ 1+ 0))

input: (TUP+ (QUOTE ((1+ 1+ 1+ 0) (1+ 1+ 1+ 1+ 0))) (QUOTE ((0))))
output: ((1+ 1+ 1+ 0) (1+ 1+ 1+ 1+ 0))

input: (TUP+ (QUOTE ((1+ 0) (1+ 1+ 0))) (QUOTE ((1+ 1+ 1+ 0) (1+ 1+ 1+ 1+ 0))))
output: ((1+ 1+ 1+ 1+ 0) (1+ 1+ 1+ 1+ 1+ 1+ 0))

; Comparisons
;
; >
input: (> ZERO ZERO)
output: NIL

input: (> ONE ZERO)
output: T

input: (> ONE ONE)
output: NIL

input: (> ONE TWO)
output: NIL

; <
input: (< ZERO ZERO)
output: NIL

input: (< ONE ZERO)
output: NIL

input: (< ONE ONE)
output: NIL

input: (< ONE TWO)
output: T

; =
input: (= ZERO ZERO)
output: T

input: (= ONE ZERO)
output: NIL

input: (= ONE ONE)
output: T

input: (= ONE TWO)
output: NIL

; EQAN
input: (EQAN? ONE ONE)
output: T

input: (EQAN? FIVE FIVE)
output: T

input: (EQAN? ONE TWO)
output: NIL

input: (EQAN? ONE (QUOTE ONE))
output: NIL

input: (EQAN? (QUOTE ONE) ONE)
output: NIL

input: (EQAN? (QUOTE ONE) (QUOTE ONE))
output: T

input: (EQAN? (QUOTE APPLES) (QUOTE ORANGES))
output: NIL

; length of list
input: (LENGTH NIL)
output: (0)

input: (LENGTH (QUOTE ()))
output: (0)

input: (LENGTH (QUOTE (A)))
output: (1+ 0)

input: (LENGTH (QUOTE (A B)))
output: (1+ 1+ 0)

input: (LENGTH (QUOTE (A B C)))
output: (1+ 1+ 1+ 0)

; pick item out of list
input: (PICK ZERO (QUOTE (A B C D E F G)))
output: *UNDEFINED

input: (PICK ONE (QUOTE ()))
output: *UNDEFINED

input: (PICK ONE (QUOTE (A B C D E F G)))
output: A

input: (PICK TWO (QUOTE (A B C D E F G)))
output: B

input: (PICK THREE (QUOTE (A B C D E F G)))
output: C

input: (PICK FOUR (QUOTE (A B C D E F G)))
output: D

input: (PICK FIVE (QUOTE (A B C D E F G)))
output: E

; remove item n from list
input: (REMPICK ZERO (QUOTE (A B C D E F G)))
output: *UNDEFINED

input: (REMPICK ONE (QUOTE ()))
output: *UNDEFINED

input: (REMPICK ONE (QUOTE (A B C D E F G)))
output: (B C D E F G)

input: (REMPICK TWO (QUOTE (A B C D E F G)))
output: (A C D E F G)

input: (REMPICK THREE (QUOTE (A B C D E F G)))
output: (A B D E F G)

input: (REMPICK FOUR (QUOTE (A B C D E F G)))
output: (A B C E F G)

input: (REMPICK FIVE (QUOTE (A B C D E F G)))
output: (A B C D F G)

input: (REMPICK FIVE (QUOTE (A B C)))
output: *UNDEFINED

; Count the number of times an atom appears in a list
; Note that we're treating numbers as atoms which isn't really true here

input: (OCCUR (QUOTE A) (QUOTE ())
output (0)

input: (OCCUR (QUOTE Z) (QUOTE (A (0) B (1+ 0) C (1+ 1+ 0) D (1+ 1+ 1+ 0) A (0) B (1+ 0) C (1+ 1+ 0) D (1+ 1+ 1+ 0))))
output: (0)

input: (OCCUR (QUOTE A) (QUOTE (A (0) B (1+ 0) C (1+ 1+ 0) D (1+ 1+ 1+ 0) A (0) B (1+ 0) C (1+ 1+ 0) D (1+ 1+ 1+ 0))))
output: (1+ 1+ 0)

input: (OCCUR (QUOTE (0)) (QUOTE (A (0) B (1+ 0) C (1+ 1+ 0) D (1+ 1+ 1+ 0) A (0) B (1+ 0) C (1+ 1+ 0) D (1+ 1+ 1+ 0))))
output: (1+ 1+ 0)

input: (OCCUR (QUOTE (1+ 1+ 1+ 0)) (QUOTE (A (0) B (1+ 0) C (1+ 1+ 0) D (1+ 1+ 1+ 0) A (0) B (1+ 0) C (1+ 1+ 0) D (1+ 1+ 1+ 0))))
output: (1+ 1+ 0)

